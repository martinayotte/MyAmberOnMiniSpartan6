   1              	# 1 "mini-libc/libc_asm.S"
   1              	/*----------------------------------------------------------------
   0              	
   0              	
   2              	//                                                              //
   3              	//  libc_asm.S                                                  //
   4              	//                                                              //
   5              	//  This file is part of the Amber project                      //
   6              	//  http://www.opencores.org/project,amber                      //
   7              	//                                                              //
   8              	//  Description                                                 //
   9              	//  Assembly routines for the mini-libc library.                //
  10              	//                                                              //
  11              	//  Author(s):                                                  //
  12              	//      - Conor Santifort, csantifort.amber@gmail.com           //
  13              	//                                                              //
  14              	//////////////////////////////////////////////////////////////////
  15              	//                                                              //
  16              	// Copyright (C) 2010 Authors and OPENCORES.ORG                 //
  17              	//                                                              //
  18              	// This source file may be used and distributed without         //
  19              	// restriction provided that this copyright statement is not    //
  20              	// removed from the file and that any derivative work contains  //
  21              	// the original copyright notice and the associated disclaimer. //
  22              	//                                                              //
  23              	// This source file is free software; you can redistribute it   //
  24              	// and/or modify it under the terms of the GNU Lesser General   //
  25              	// Public License as published by the Free Software Foundation; //
  26              	// either version 2.1 of the License, or (at your option) any   //
  27              	// later version.                                               //
  28              	//                                                              //
  29              	// This source is distributed in the hope that it will be       //
  30              	// useful, but WITHOUT ANY WARRANTY; without even the implied   //
  31              	// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      //
  32              	// PURPOSE.  See the GNU Lesser General Public License for more //
  33              	// details.                                                     //
  34              	//                                                              //
  35              	// You should have received a copy of the GNU Lesser General    //
  36              	// Public License along with this source; if not, download it   //
  37              	// from http://www.opencores.org/lgpl.shtml                     //
  38              	//                                                              //
  39              	----------------------------------------------------------------*/
  40              	
  41              	#include "amber_registers.h"
   1              	/*----------------------------------------------------------------
  42              	
  43              	
  44              	/* _testfail: Used to terminate execution in Verilog simulations */
  45              	/* On the board just puts the processor into an infinite loop    */
  46              		.section .text
  47              		.globl _testfail      
  48              	_testfail:
  49 0000 6CB49FE5 	        ldr     r11, AdrTestStatus
  50 0004 00008BE5 	        str     r0, [r11]
  51 0008 FEFFFFEA 	        b       _testfail
  52              	
  53              	        
  54              	/* _testpass: Used to terminate execution in Verilog simulations */
  55              	/* On the board just puts the processor into an infinite loop    */
  56              		.globl _testpass      
  57              	_testpass:             
  58 000c 60B49FE5 	        ldr     r11, AdrTestStatus
  59 0010 11A0A0E3 	        mov     r10, #17
  60 0014 00A08BE5 	        str     r10, [r11]
  61 0018 FEFFFFEA 	        b       _testpass
  62              	
  63              	/* _outbyte: Output a single character through UART 0 */
  64              	        @ if the uart tx fifo is stuck full
  65              	        @ this routine will cycle forever
  66              		.globl _outbyte      
  67              	_outbyte:        
  68 001c 54149FE5 	        ldr     r1, AdrUARTDR
  69 0020 54349FE5 	        ldr     r3, AdrUARTFR
  70              	        @ Check the tx_full flag
  71 0024 002093E5 	1:      ldr     r2, [r3]
  72 0028 202002E2 	        and     r2, r2, #0x20
  73              	//        and     r2, r2, #0x00
  74 002c 000052E3 	        cmp     r2, #0
  75 0030 0000C105 	        streqb  r0, [r1]
  76 0034 0EF0B001 	        moveqs  pc, lr          @ return
  77 0038 F9FFFF1A 	        bne     1b
  78              	
  79              	
  80              	/* _inbyte: Input a single character from UART 0 */
  81              	        @ r0 is the timeout in mS
  82              		.globl _inbyte      
  83              	_inbyte:        
  84 003c 34249FE5 	        ldr     r2, AdrUARTDR @ data
  85 0040 34349FE5 	        ldr     r3, AdrUARTFR @ flags
  86              	        
  87              	        @ Multiple delay value by 2560
  88              	        @ as the delay loop takes about 12 clock cycles running cached
  89              	        @ so that factor gives 1:1mS @33MHz
  90 0044 8015A0E1 	        mov     r1, r0, lsl #11
  91 0048 801481E0 	        add     r1, r1, r0, lsl #9
  92              	        
  93              	        @ Check the r2 empty flag
  94 004c 000093E5 	2:      ldr     r0, [r3]
  95 0050 100010E2 	        ands    r0, r0, #0x10
  96 0054 0000D205 	        ldreqb  r0, [r2]
  97 0058 0EF0A001 	        moveq   pc, lr
  98              	        
  99              	        @ decrement timeout
 100 005c 011051E2 	        subs    r1, r1, #1
 101 0060 F9FFFF1A 	        bne     2b
 102              	        
 103 0064 0000E0E3 	        mov     r0, #-1
 104 0068 0EF0B0E1 	        movs    pc, lr
 105              	
 106              	
 107              	/* _div: Integer division function */
 108              	        @ Divide r0 by r1
 109              	        @ Answer returned in r1
 110              	        .globl _div
 111              	        .globl __aeabi_idiv
 112              	__aeabi_idiv:
 113              	_div:
 114 006c 10402DE9 	        stmdb   sp!, {r4, lr}
 115              	
 116              	        @ set r4 to 1 if one of the two inputs is negative
 117 0070 022100E2 	        and     r2, r0, #0x80000000
 118 0074 023101E2 	        and     r3, r1, #0x80000000
 119 0078 034022E0 	        eor     r4, r2, r3
 120              	
 121              	        @ Invert negative numbers
 122 007c 020110E3 	        tst     r0, #0x80000000
 123 0080 0000E011 	        mvnne   r0, r0
 124 0084 01008012 	        addne   r0, r0, #1 
 125              	
 126 0088 020111E3 	        tst     r1, #0x80000000
 127 008c 0110E011 	        mvnne   r1, r1
 128 0090 01108112 	        addne   r1, r1, #1 
 129              	
 130              	        @ divide r1 by r2, also use registers r0 and r4
 131 0094 0120A0E1 	        mov     r2, r1
 132 0098 0010A0E1 	        mov     r1, r0
 133              	        
 134 009c 000052E3 	        cmp      r2, #0
 135 00a0 1100000A 	        beq      3f
 136              	
 137              	        @ In order to divide r1 by r2, the first thing we need to do is to shift r2 
 138              	        @ left by the necessary number of places. The easiest method of doing this 
 139              	        @ is simply by trial and error - shift until we discover that r2 has become 
 140              	        @ too big, then stop.
 141 00a4 0000A0E3 	        mov      r0,#0     @ clear r0 to accumulate result
 142 00a8 0130A0E3 	        mov      r3,#1     @ set bit 0 in r3, which will be
 143              	                           @ shifted left then right
 144              	
 145 00ac 000053E3 	1:      cmp      r3, #0    @ escape on error
 146 00b0 0132A003 	        moveq    r3, #0x10000000
 147 00b4 0300000A 	        beq      2f
 148 00b8 010052E1 	        cmp      r2,r1
 149 00bc 8220A091 	        movls    r2,r2,lsl#1
 150 00c0 8330A091 	        movls    r3,r3,lsl#1
 151 00c4 F8FFFF9A 	        bls      1b
 152              	        @ shift r2 left until it is about to be bigger than r1
 153              	        @ shift r3 left in parallel in order to flag how far we have to go
 154              	
 155              	        @ r0 will be used to hold the result. The role of r3 is more complicated.
 156              	        @ In effect, we are using r3 to mark where the right-hand end of r2 has got to 
 157              	        @ - if we shift r2 three places left, this will be indicated by a value of %1000 
 158              	        @ in r3. However, we also add it to r0 every time we manage a successful subtraction, 
 159              	        @ since it marks the position of the digit currently being calculated in the answer. 
 160              	        @ In the binary example (50 ÷ 10) above, we shifted the '10' two places left, 
 161              	        @ so at the time of the first subtraction, r3 would have been %100, at the time 
 162              	        @ of the second (which failed) it would have been %10, and at the time of the 
 163              	        @ third %1. Adding it to r0 after each successful subtraction would have 
 164              	        @ given us, once again, the answer of %101!
 165              	
 166              	        @ Now for the loop that actually does the work:
 167 00c8 020051E1 	2:      cmp       r1,r2      @ carry set if r1>r2 (don't ask why)
 168 00cc 02104120 	        subcs     r1,r1,r2   @ subtract r2 from r1 if this would
 169              	                             @ give a positive answer
 170 00d0 03008020 	        addcs     r0,r0,r3   @ and add the current bit in r3 to
 171              	                             @ the accumulating answer in r0
 172              	
 173              	        @ In subtraction (a cmp instruction simulates a subtraction in 
 174              	        @ order to set the flags), if r1 - r2 gives a positive answer and no 'borrow' 
 175              	        @ is required, the carry flag is set. This is required in order to make SBC 
 176              	        @ (Subtract with Carry) work properly when used to carry out a 64-bit subtraction, 
 177              	        @ but it is confusing!
 178              	        
 179              	        @ In this case, we are turning it to our advantage. The carry flag is set to 
 180              	        @ indicate that a successful subtraction is possible, i.e. one that doesn't 
 181              	        @ generate a negative result, and the two following instructions are carried 
 182              	        @ out only when the condition Carry Set applies. Note that the 'S' on the end 
 183              	        @ of these instructions is part of the 'CS' condition code and does not mean 
 184              	        @ that they set the flags!
 185              	        
 186 00d4 A330B0E1 	        movs      r3,r3,lsr #1    @ Shift r3 right into carry flag
 187 00d8 A220A031 	        movcc     r2,r2,lsr #1    @ and if bit 0 of r3 was zero, also
 188              	                                  @ shift r2 right
 189 00dc F9FFFF3A 	        bcc       2b              @ If carry not clear, r3 has shifted
 190              	                                  @ back to where it started, and we
 191              	                                  @ can end
 192              	                                  
 193              	        @ if one of the inputs is negetive then return a negative result                          
 194 00e0 020114E3 	        tst     r4, #0x80000000
 195 00e4 0000E011 	        mvnne   r0, r0
 196 00e8 01008012 	        addne   r0, r0, #1 
 197 00ec 1080FDE8 	3:      ldmia	sp!, {r4, pc}^
 198              	
 199              	
 200              	/* strcpy: String copy function 
 201              	    char * strcpy ( char * destination, const char * source );
 202              	    destination is returned
 203              	*/    
 204              	        @ r0 points to destination
 205              	        @ r1 points to source string which terminates with a 0    
 206              	        .globl strcpy
 207              	strcpy:
 208 00f0 70402DE9 	        stmdb   sp!, {r4-r6, lr}
 209              	        @ Use r6 to process the destination pointer.
 210              	        @ At the end of the function, r0 is returned, so need to preserve it
 211 00f4 0060A0E1 	        mov     r6, r0
 212              	        @ only if both strings are zero-aligned use the fast 'aligned' algorithm
 213 00f8 012086E1 	        orr     r2, r6, r1
 214 00fc 030012E3 	        tst     r2, #3
 215 0100 2A00001A 	        bne     strcpy_slow
 216              	
 217              	strcpy_fast:
 218              	        @ process strings 12 bytes at a time
 219 0104 3C00B1E8 	        ldmia   r1!, {r2-r5}
 220              	
 221              	        @ check for a zero byte
 222              	        @ only need to examine one of the strings because
 223              	        @ they are equal up to this point!
 224 0108 FF0012E3 	        tst     r2, #0xff
 225 010c FF0C1213 	        tstne   r2, #0xff00
 226 0110 FF081213 	        tstne   r2, #0xff0000
 227 0114 FF041213 	        tstne   r2, #0xff000000
 228 0118 04208614 	        strne   r2, [r6], #4
 229 011c 04104102 	        subeq   r1, r1, #4
 230              	                
 231 0120 FF001313 	        tstne   r3, #0xff
 232 0124 FF0C1313 	        tstne   r3, #0xff00
 233 0128 FF081313 	        tstne   r3, #0xff0000
 234 012c FF041313 	        tstne   r3, #0xff000000
 235 0130 04308614 	        strne   r3, [r6], #4
 236 0134 04104102 	        subeq   r1, r1, #4
 237              	        
 238 0138 FF001413 	        tstne   r4, #0xff
 239 013c FF0C1413 	        tstne   r4, #0xff00
 240 0140 FF081413 	        tstne   r4, #0xff0000
 241 0144 FF041413 	        tstne   r4, #0xff000000
 242 0148 04408614 	        strne   r4, [r6], #4
 243 014c 04104102 	        subeq   r1, r1, #4
 244              	
 245 0150 FF001513 	        tstne   r5, #0xff
 246 0154 FF0C1513 	        tstne   r5, #0xff00
 247 0158 FF081513 	        tstne   r5, #0xff0000
 248 015c FF041513 	        tstne   r5, #0xff000000
 249 0160 04508614 	        strne   r5, [r6], #4
 250 0164 04104102 	        subeq   r1, r1, #4
 251              	        
 252              	        @ loop back to look at next 12 bytes
 253 0168 E5FFFF1A 	        bne     strcpy_fast
 254              	
 255              	        @ the source string contains a zero character
 256              	
 257              	
 258              	strcpy_aligned_slow:
 259              	        @ unroll the loop 4 times
 260 016c 043091E4 	        ldr     r3, [r1], #4
 261 0170 0130C6E4 	        strb    r3, [r6], #1
 262 0174 FF4013E2 	        ands    r4, r3,   #0xff
 263 0178 7080FD08 	        ldmeqia	sp!, {r4-r6, pc}^
 264              	        
 265 017c 2334A0E1 	        lsr     r3, r3, #8
 266 0180 0130C6E4 	        strb    r3, [r6], #1
 267 0184 FF4013E2 	        ands    r4, r3,   #0xff
 268 0188 7080FD08 	        ldmeqia	sp!, {r4-r6, pc}^
 269              	        
 270 018c 2334A0E1 	        lsr     r3, r3, #8
 271 0190 0130C6E4 	        strb    r3, [r6], #1
 272 0194 FF4013E2 	        ands    r4, r3,   #0xff
 273 0198 7080FD08 	        ldmeqia	sp!, {r4-r6, pc}^
 274              	        
 275 019c 2334A0E1 	        lsr     r3, r3, #8
 276 01a0 0130C6E4 	        strb    r3, [r6], #1
 277 01a4 FF4013E2 	        ands    r4, r3,   #0xff
 278 01a8 7080FD08 	        ldmeqia	sp!, {r4-r6, pc}^
 279              	        
 280 01ac EEFFFFEA 	        b       strcpy_aligned_slow  
 281              	
 282              	
 283              	strcpy_slow:
 284              	        @ unroll the loop 4 times
 285 01b0 0130D1E4 	        ldrb    r3, [r1], #1
 286 01b4 0130C6E4 	        strb    r3, [r6], #1
 287 01b8 000053E3 	        cmp     r3, #0
 288 01bc 7080FD08 	        ldmeqia	sp!, {r4-r6, pc}^
 289              	        
 290 01c0 0130D1E4 	        ldrb    r3, [r1], #1
 291 01c4 0130C6E4 	        strb    r3, [r6], #1
 292 01c8 000053E3 	        cmp     r3, #0
 293 01cc 7080FD08 	        ldmeqia	sp!, {r4-r6, pc}^
 294              	        
 295 01d0 0130D1E4 	        ldrb    r3, [r1], #1
 296 01d4 0130C6E4 	        strb    r3, [r6], #1
 297 01d8 000053E3 	        cmp     r3, #0
 298 01dc 7080FD08 	        ldmeqia	sp!, {r4-r6, pc}^
 299              	        
 300 01e0 0130D1E4 	        ldrb    r3, [r1], #1
 301 01e4 0130C6E4 	        strb    r3, [r6], #1
 302 01e8 000053E3 	        cmp     r3, #0
 303 01ec 7080FD08 	        ldmeqia	sp!, {r4-r6, pc}^
 304              	        
 305 01f0 EEFFFFEA 	        b       strcpy_slow
 306              	
 307              	
 308              	/* int strcmp ( const char * str1, const char * str2 );
 309              	   A value greater than zero indicates that the first character 
 310              	   that does not match has a greater value in str1 than in str2; 
 311              	   And a value less than zero indicates the opposite.
 312              	*/   
 313              	        .globl strcmp
 314              	strcmp: 
 315 01f4 F0412DE9 	        stmdb   sp!, {r4-r8, lr}
 316              	        
 317              	        @ only if both strings are zero-aligned use the fast 'aligned' algorithm
 318 01f8 012080E1 	        orr     r2, r0, r1
 319 01fc 030012E3 	        tst     r2, #3
 320 0200 1800001A 	        bne     strcmp_slow
 321              	        
 322              	strcmp_fast:
 323              	        @ process strings 12 bytes at a time
 324 0204 1C00B0E8 	        ldmia   r0!, {r2-r4}
 325 0208 E000B1E8 	        ldmia   r1!, {r5-r7}
 326 020c 050052E1 	        cmp     r2, r5
 327 0210 1200001A 	        bne     1f
 328 0214 06005301 	        cmpeq   r3, r6
 329 0218 2B00001A 	        bne     2f
 330 021c 07005401 	        cmpeq   r4, r7
 331 0220 4900001A 	        bne     3f
 332              	
 333              	        @ strings are equal - find a zero byte
 334              	        @ only need to examine one of the strings because
 335              	        @ they are equal up to this point!
 336 0224 FF0012E3 	        tst     r2, #0xff
 337 0228 FF0C1213 	        tstne   r2, #0xff00
 338 022c FF081213 	        tstne   r2, #0xff0000
 339 0230 FF041213 	        tstne   r2, #0xff000000
 340              	        
 341 0234 FF001313 	        tstne   r3, #0xff
 342 0238 FF0C1313 	        tstne   r3, #0xff00
 343 023c FF081313 	        tstne   r3, #0xff0000
 344 0240 FF041313 	        tstne   r3, #0xff000000
 345              	        
 346 0244 FF001413 	        tstne   r4, #0xff
 347 0248 FF0C1413 	        tstne   r4, #0xff00
 348 024c FF081413 	        tstne   r4, #0xff0000
 349 0250 FF041413 	        tstne   r4, #0xff000000
 350              	        
 351              	        @ loop back to look at next 12 bytes
 352 0254 EAFFFF1A 	        bne     strcmp_fast
 353              	
 354              	        @ the first string contains a zero character
 355              	        @ the strings are the same, so both strings end
 356 0258 0000A003 	        moveq   r0, #0
 357 025c F081FD08 	        ldmeqia	sp!, {r4-r8, pc}^
 358              	
 359              	
 360              	        @ Roll back the string pointers to before the mismatch
 361              	        @ then handle the remaining part byte by byte
 362 0260 0C0040E2 	1:      sub     r0, r0, #12
 363 0264 0C1041E2 	        sub     r1, r1, #12
 364              	
 365              	strcmp_slow:         
 366 0268 0120D0E4 	        ldrb    r2, [r0], #1
 367 026c 0130D1E4 	        ldrb    r3, [r1], #1
 368 0270 034032E0 	        eors    r4, r2, r3          @ are the bytes equal ?
 369 0274 5A00001A 	        bne     bytes_different
 370 0278 0150D0E4 	        ldrb    r5, [r0], #1
 371 027c 0160D1E4 	        ldrb    r6, [r1], #1
 372 0280 000052E3 	        cmp     r2, #0              @ are they equal and zero ?
 373 0284 5400000A 	        beq     bytes_zero
 374 0288 067035E0 	        eors    r7, r5, r6          @ are the bytes equal ?
 375 028c 5400001A 	        bne     bytes_different
 376 0290 0120D0E4 	        ldrb    r2, [r0], #1
 377 0294 0130D1E4 	        ldrb    r3, [r1], #1
 378 0298 000055E3 	        cmp     r5, #0              @ are they equal and zero ?
 379 029c 4E00000A 	        beq     bytes_zero
 380 02a0 034032E0 	        eors    r4, r2, r3          @ are the bytes equal ?
 381 02a4 4E00001A 	        bne     bytes_different
 382 02a8 0150D0E4 	        ldrb    r5, [r0], #1
 383 02ac 0160D1E4 	        ldrb    r6, [r1], #1
 384 02b0 000052E3 	        cmp     r2, #0              @ are they equal and zero ?
 385 02b4 4800000A 	        beq     bytes_zero
 386 02b8 067035E0 	        eors    r7, r5, r6          @ are the bytes equal ?
 387 02bc 4800001A 	        bne     bytes_different
 388 02c0 000055E3 	        cmp     r5, #0              @ are they equal and zero ?
 389 02c4 4400000A 	        beq     bytes_zero
 390              	
 391 02c8 E6FFFF1A 	        bne     strcmp_slow
 392              	
 393              	
 394              	
 395              	@ Skipping first 4 bytes so just check they
 396              	@ don't contain an end of string 0 character
 397 02cc FF0012E3 	2:      tst    r2, #0xff
 398 02d0 FF0C1213 	        tstne  r2, #0xff00
 399 02d4 FF081213 	        tstne  r2, #0xff0000
 400 02d8 FF041213 	        tstne  r2, #0xff000000
 401 02dc 3E00000A 	        beq     bytes_zero
 402              	        
 403              	        @ start looking at 5th byte
 404 02e0 080040E2 	        sub     r0, r0, #8
 405 02e4 081041E2 	        sub     r1, r1, #8
 406              	        
 407 02e8 0120D0E4 	        ldrb    r2, [r0], #1
 408 02ec 0130D1E4 	        ldrb    r3, [r1], #1
 409 02f0 034032E0 	        eors    r4, r2, r3          @ are the bytes equal ?
 410 02f4 3A00001A 	        bne     bytes_different
 411 02f8 0150D0E4 	        ldrb    r5, [r0], #1
 412 02fc 0160D1E4 	        ldrb    r6, [r1], #1
 413 0300 000052E3 	        cmp     r2, #0              @ are they equal and zero ?
 414 0304 3400000A 	        beq     bytes_zero
 415 0308 067035E0 	        eors    r7, r5, r6          @ are the bytes equal ?
 416 030c 3400001A 	        bne     bytes_different
 417 0310 0120D0E4 	        ldrb    r2, [r0], #1
 418 0314 0130D1E4 	        ldrb    r3, [r1], #1
 419 0318 000055E3 	        cmp     r5, #0              @ are they equal and zero ?
 420 031c 2E00000A 	        beq     bytes_zero
 421 0320 034032E0 	        eors    r4, r2, r3          @ are the bytes equal ?
 422 0324 2E00001A 	        bne     bytes_different
 423 0328 0150D0E4 	        ldrb    r5, [r0], #1
 424 032c 0160D1E4 	        ldrb    r6, [r1], #1
 425 0330 000052E3 	        cmp     r2, #0              @ are they equal and zero ?
 426 0334 2800000A 	        beq     bytes_zero
 427 0338 067035E0 	        eors    r7, r5, r6          @ are the bytes equal ?
 428 033c 2800001A 	        bne     bytes_different
 429 0340 000055E3 	        cmp     r5, #0              @ are they equal and zero ?
 430 0344 2400000A 	        beq     bytes_zero
 431              	
 432 0348 C6FFFF1A 	        bne     strcmp_slow
 433              	        
 434              	@ Skipping first 8 bytes so just check they
 435              	@ don't contain an end of string 0 character
 436 034c FF0012E3 	3:      tst     r2, #0xff
 437 0350 FF0C1213 	        tstne   r2, #0xff00
 438 0354 FF081213 	        tstne   r2, #0xff0000
 439 0358 FF041213 	        tstne   r2, #0xff000000
 440              	        
 441 035c FF001313 	        tstne   r3, #0xff
 442 0360 FF0C1313 	        tstne   r3, #0xff00
 443 0364 FF081313 	        tstne   r3, #0xff0000
 444 0368 FF041313 	        tstne   r3, #0xff000000
 445 036c 1A00000A 	        beq     bytes_zero
 446              	        
 447 0370 040040E2 	        sub     r0, r0, #4
 448 0374 041041E2 	        sub     r1, r1, #4
 449 0378 0120D0E4 	        ldrb    r2, [r0], #1
 450 037c 0130D1E4 	        ldrb    r3, [r1], #1
 451 0380 034032E0 	        eors    r4, r2, r3          @ are the bytes equal ?
 452 0384 1600001A 	        bne     bytes_different
 453 0388 0150D0E4 	        ldrb    r5, [r0], #1
 454 038c 0160D1E4 	        ldrb    r6, [r1], #1
 455 0390 000052E3 	        cmp     r2, #0              @ are they equal and zero ?
 456 0394 1000000A 	        beq     bytes_zero
 457 0398 067035E0 	        eors    r7, r5, r6          @ are the bytes equal ?
 458 039c 1000001A 	        bne     bytes_different
 459 03a0 0120D0E4 	        ldrb    r2, [r0], #1
 460 03a4 0130D1E4 	        ldrb    r3, [r1], #1
 461 03a8 000055E3 	        cmp     r5, #0              @ are they equal and zero ?
 462 03ac 0A00000A 	        beq     bytes_zero
 463 03b0 034032E0 	        eors    r4, r2, r3          @ are the bytes equal ?
 464 03b4 0A00001A 	        bne     bytes_different
 465 03b8 0150D0E4 	        ldrb    r5, [r0], #1
 466 03bc 0160D1E4 	        ldrb    r6, [r1], #1
 467 03c0 000052E3 	        cmp     r2, #0              @ are they equal and zero ?
 468 03c4 0400000A 	        beq     bytes_zero
 469 03c8 067035E0 	        eors    r7, r5, r6          @ are the bytes equal ?
 470 03cc 0400001A 	        bne     bytes_different
 471 03d0 000055E3 	        cmp     r5, #0              @ are they equal and zero ?
 472 03d4 0000000A 	        beq     bytes_zero
 473              	
 474 03d8 A2FFFF1A 	        bne     strcmp_slow
 475              	
 476              	
 477              	bytes_zero:
 478 03dc 0000A003 	        moveq   r0, #0              @ if equal and zero, return zero
 479 03e0 F081FD08 	        ldmeqia	sp!, {r4-r8, pc}^
 480              	
 481              	
 482              	bytes_different:        
 483 03e4 060045E0 	        sub     r0, r5, r6
 484 03e8 F081FDE8 	        ldmia	sp!, {r4-r8, pc}^
 485              	        
 486              	
 487              	        @ initialize malloc
 488              	        .globl init_malloc
 489              	init_malloc:
 490 03ec 7C109FE5 	        ldr     r1, AdrMalloc
 491 03f0 001081E5 	        str     r1, [r1]
 492 03f4 0EF0A0E1 	        mov     pc, lr
 493              	
 494              	
 495              	        /* void *malloc(size_t size); */
 496              	        .globl malloc
 497              	malloc:
 498 03f8 70109FE5 	        ldr     r1, AdrMalloc
 499 03fc 000091E5 	        ldr     r0, [r1]
 500 0400 010880E2 	        add     r0, r0, #0x10000
 501 0404 000081E5 	        str     r0, [r1]
 502 0408 0EF0A0E1 	        mov     pc, lr
 503              	
 504              	
 505              	
 506              	/* strncpy: String copy function */
 507              	        @ r0 points to destination
 508              	        @ r1 points to source string
 509              	        @ r2 is the number of bytes to copy
 510              	        .globl strncpy
 511              	strncpy: 
 512 040c 10402DE9 	        stmdb	sp!, {r4, lr}
 513 0410 000052E3 	        cmp     r2, #0
 514 0414 0400000A 	        beq     2f
 515 0418 024080E0 	        add     r4, r0, r2    @ set r4 to the address of the last byte copied
 516 041c 0130D1E4 	1:      ldrb    r3, [r1], #1
 517 0420 0130C0E4 	        strb    r3, [r0], #1
 518 0424 040050E1 	        cmp     r0,  r4
 519 0428 FBFFFF1A 	        bne     1b
 520 042c 1080FDE8 	2:      ldmia	sp!, {r4, pc}^
 521              	
 522              	 
 523              	/* strncpy: String compare function */
 524              	        @ return the difference if the strings don't match
 525              	        .globl strncmp
 526              	strncmp:
 527 0430 70402DE9 	        stmdb	sp!, {r4, r5, r6, lr}
 528              	        
 529              	        @ check for 0 length
 530 0434 000052E3 	        cmp     r2, #0
 531 0438 0100A003 	        moveq   r0, #1
 532 043c 0A00000A 	        beq     2f
 533              	        
 534 0440 0030A0E3 	        mov     r3, #0
 535              	        
 536 0444 013083E2 	1:      add     r3, r3,   #1
 537 0448 0140D0E4 	        ldrb    r4, [r0], #1
 538 044c 0150D1E4 	        ldrb    r5, [r1], #1
 539              	        
 540 0450 056054E0 	        subs    r6, r4, r5
 541 0454 0600A011 	        movne   r0, r6
 542 0458 0300001A 	        bne     2f
 543              	        
 544 045c 020053E1 	        cmp     r3, r2
 545 0460 0000A003 	        moveq   r0, #0
 546 0464 0000000A 	        beq     2f
 547              	        
 548 0468 F5FFFFEA 	        b       1b
 549 046c 7080FDE8 	2:      ldmia	sp!, {r4, r5, r6, pc}^
 550              	
 551              	
 552 0470 00000007 	AdrMalloc:      .word  0x7000000
 553 0474 000000F0 	AdrTestStatus:  .word  ADR_AMBER_TEST_STATUS
 554 0478 00000016 	AdrUARTDR:      .word  ADR_AMBER_UART0_DR
 555 047c 18000016 	AdrUARTFR:      .word  ADR_AMBER_UART0_FR
DEFINED SYMBOLS
mini-libc/libc_asm.S:48     .text:00000000 _testfail
mini-libc/libc_asm.S:553    .text:00000474 AdrTestStatus
mini-libc/libc_asm.S:49     .text:00000000 $a
mini-libc/libc_asm.S:57     .text:0000000c _testpass
mini-libc/libc_asm.S:67     .text:0000001c _outbyte
mini-libc/libc_asm.S:554    .text:00000478 AdrUARTDR
mini-libc/libc_asm.S:555    .text:0000047c AdrUARTFR
mini-libc/libc_asm.S:83     .text:0000003c _inbyte
mini-libc/libc_asm.S:113    .text:0000006c _div
mini-libc/libc_asm.S:112    .text:0000006c __aeabi_idiv
mini-libc/libc_asm.S:207    .text:000000f0 strcpy
mini-libc/libc_asm.S:283    .text:000001b0 strcpy_slow
mini-libc/libc_asm.S:217    .text:00000104 strcpy_fast
mini-libc/libc_asm.S:258    .text:0000016c strcpy_aligned_slow
mini-libc/libc_asm.S:314    .text:000001f4 strcmp
mini-libc/libc_asm.S:365    .text:00000268 strcmp_slow
mini-libc/libc_asm.S:322    .text:00000204 strcmp_fast
mini-libc/libc_asm.S:482    .text:000003e4 bytes_different
mini-libc/libc_asm.S:477    .text:000003dc bytes_zero
mini-libc/libc_asm.S:489    .text:000003ec init_malloc
mini-libc/libc_asm.S:552    .text:00000470 AdrMalloc
mini-libc/libc_asm.S:497    .text:000003f8 malloc
mini-libc/libc_asm.S:511    .text:0000040c strncpy
mini-libc/libc_asm.S:526    .text:00000430 strncmp
mini-libc/libc_asm.S:552    .text:00000470 $d
                   .debug_aranges:0000000c $d

NO UNDEFINED SYMBOLS
